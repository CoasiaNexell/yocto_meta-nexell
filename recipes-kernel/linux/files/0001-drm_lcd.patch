>From 2e82fa970c2ba3176f5fd6811f30b171c90d9726 Mon Sep 17 00:00:00 2001
From: HyejungKwon <cjscld15@nexell.co.kr>
Date: Thu, 11 Aug 2016 15:20:53 +0900
Subject: [PATCH] drm_lcd

Change-Id: I265f4c95dc820cbf933fffef69c2f9d4f6becff3
---
 drivers/gpu/drm/nexell/nx_drm_hdmi.c | 31 ++++++++++---
 drivers/gpu/drm/nexell/nx_drm_lcd.c  | 84 +++++++++++++++++++++++++++++++-----
 drivers/gpu/drm/nexell/nx_drm_tv.c   | 20 +++++----
 3 files changed, 110 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/nexell/nx_drm_hdmi.c b/drivers/gpu/drm/nexell/nx_drm_hdmi.c
index 0e82a94..e6ec9ab 100644
--- a/drivers/gpu/drm/nexell/nx_drm_hdmi.c
+++ b/drivers/gpu/drm/nexell/nx_drm_hdmi.c
@@ -27,7 +27,7 @@
 #include <linux/of_graph.h>
 #include <linux/of_gpio.h>
 #include <video/of_display_timing.h>
-
+#include <dt-bindings/gpio/gpio.h>
 #include <drm/nexell_drm.h>
 
 #include "nx_drm_drv.h"
@@ -492,6 +492,7 @@ static int panel_hdmi_parse_dt(struct platform_device *pdev,
 	struct device_node *node = dev->of_node;
 	struct nx_drm_device *display = ctx->display;
 	struct nx_drm_panel *panel = &ctx->display->panel;
+	struct gpio_desc *desc;
 	int err;
 
 	DRM_INFO("Load HDMI panel\n");
@@ -518,11 +519,31 @@ static int panel_hdmi_parse_dt(struct platform_device *pdev,
 	if (0 > err)
 		return err;
 
-	ctx->enable_gpio =
-			devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_LOW);
+	desc = devm_gpiod_get_optional(dev, "enable", GPIOD_ASIS);
+	if (-EBUSY == (long)ERR_CAST(desc)) {
+		DRM_ERROR("fail : enable-gpios is busy : %s !!!\n",
+			node->full_name);
+		desc = NULL;
+	}
+
+	if (!IS_ERR(desc) && desc) {
+		enum of_gpio_flags flags;
+		int gpio;
+
+		gpio = of_get_named_gpio_flags(node, "enable-gpios", 0, &flags);
+		if (!gpio_is_valid(gpio)) {
+			DRM_ERROR("invalid gpio.%d\n", gpio);
+			return -EINVAL;
+		}
 
-	if (ctx->enable_gpio)
-		gpiod_set_value_cansleep(ctx->enable_gpio, 1);
+		/* enable at boottime */
+		gpiod_direction_output(desc,
+					flags == GPIO_ACTIVE_HIGH ? 1 : 0);
+		ctx->enable_gpio = desc;
+
+		DRM_INFO("HDMI enable-gpio.%d act %s\n", gpio,
+				flags == GPIO_ACTIVE_HIGH ? "high" : "low ");
+	}
 
 	parse_read_prop(node, "width-mm", panel->width_mm);
 	parse_read_prop(node, "height-mm", panel->height_mm);
diff --git a/drivers/gpu/drm/nexell/nx_drm_lcd.c b/drivers/gpu/drm/nexell/nx_drm_lcd.c
index 46752b8..5d58d37 100644
--- a/drivers/gpu/drm/nexell/nx_drm_lcd.c
+++ b/drivers/gpu/drm/nexell/nx_drm_lcd.c
@@ -26,7 +26,7 @@
 #include <linux/of_graph.h>
 #include <linux/of_gpio.h>
 #include <video/of_display_timing.h>
-
+#include <dt-bindings/gpio/gpio.h>
 #include <drm/nexell_drm.h>
 
 #include "nx_drm_drv.h"
@@ -52,7 +52,9 @@ struct lcd_context {
 	struct nx_drm_device *display;
 	struct mutex lock;
 	bool local_timing;
-	struct gpio_desc *enable_gpio;
+	struct gpio_descs *enable_gpios;
+	enum of_gpio_flags gpios_active[4];
+	int gpios_delay[4];
 	struct mipi_resource mipi_res;
 };
 
@@ -237,14 +239,31 @@ static void panel_lcd_dmps(struct device *dev, int mode)
 	struct lcd_context *ctx = dev_get_drvdata(dev);
 	struct nx_drm_panel *panel = &ctx->display->panel;
 	struct drm_panel *drm_panel = panel->panel;
+	struct gpio_desc **desc;
+	int i;
 
 	DRM_DEBUG_KMS("dpms.%d\n", mode);
+
 	switch (mode) {
 	case DRM_MODE_DPMS_ON:
 		panel_lcd_enable(dev, drm_panel);
 
-		if (!panel && ctx->enable_gpio)
-			gpiod_set_value_cansleep(ctx->enable_gpio, 1);
+		if (ctx->enable_gpios) {
+			desc = ctx->enable_gpios->desc;
+			for (i = 0; ctx->enable_gpios->ndescs > i; i++) {
+				DRM_DEBUG_KMS("LCD gpio.%d ative %s %dms\n",
+					desc_to_gpio(desc[i]),
+					ctx->gpios_active[i] == GPIO_ACTIVE_HIGH
+					? "high" : "low ",
+					ctx->gpios_delay[i]);
+
+				gpiod_set_value_cansleep(desc[i],
+						ctx->gpios_active[i] ==
+						GPIO_ACTIVE_HIGH ? 1 : 0);
+				if (ctx->gpios_delay[i])
+					mdelay(ctx->gpios_delay[i]);
+			}
+		}
 		break;
 
 	case DRM_MODE_DPMS_STANDBY:
@@ -252,8 +271,13 @@ static void panel_lcd_dmps(struct device *dev, int mode)
 	case DRM_MODE_DPMS_OFF:
 		panel_lcd_disable(dev, drm_panel);
 
-		if (!panel && ctx->enable_gpio)
-			gpiod_set_value_cansleep(ctx->enable_gpio, 0);
+		if (ctx->enable_gpios) {
+			desc = ctx->enable_gpios->desc;
+			for (i = 0; ctx->enable_gpios->ndescs > i; i++)
+				gpiod_set_value_cansleep(desc[i],
+						ctx->gpios_active[i] ==
+						GPIO_ACTIVE_HIGH ? 0 : 1);
+		}
 		break;
 	default:
 		DRM_ERROR("fail : unspecified mode %d\n", mode);
@@ -425,15 +449,53 @@ static int panel_lcd_parse_dt(struct platform_device *pdev,
 	np = of_graph_get_remote_port_parent(node);
 	panel->panel_node = np;
 	if (!np) {
+		struct gpio_descs *gpios;
+		struct gpio_desc **desc;
+		int i, ngpios = 0;
+
 		DRM_INFO("not use remote panel node (%s) !\n",
 			node->full_name);
 
-		/*
-		 * parse panel info
-		 */
-		ctx->enable_gpio =
-			devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_LOW);
+		/* parse panel gpios */
+		gpios = devm_gpiod_get_array(dev, "enable", GPIOD_ASIS);
+		if (-EBUSY == (long)ERR_CAST(gpios)) {
+			DRM_ERROR("fail : enable-gpios is busy : %s !!!\n",
+				node->full_name);
+			gpios = NULL;
+		}
+
+		if (!IS_ERR(gpios) && gpios) {
+			ngpios = gpios->ndescs;
+			desc = gpios->desc;
+			ctx->enable_gpios = gpios;	/* set enable_gpios */
+			of_property_read_u32_array(node,
+				"enable-gpios-delay", ctx->gpios_delay,
+				(ngpios-1));
+		}
+
+		for (i = 0; ngpios > i; i++) {
+			enum of_gpio_flags flags;
+			int gpio;
+
+			gpio = of_get_named_gpio_flags(node,
+						"enable-gpios", i, &flags);
+			if (!gpio_is_valid(gpio)) {
+				DRM_ERROR("invalid gpio #%d: %d\n", i, gpio);
+				return -EINVAL;
+			}
+
+			ctx->gpios_active[i] = flags;
+
+			/* disable at boottime */
+			gpiod_direction_output(desc[i],
+					flags == GPIO_ACTIVE_HIGH ? 0 : 1);
+
+			DRM_INFO("LCD enable-gpio.%d act %s\n",
+				gpio, flags == GPIO_ACTIVE_HIGH ?
+				"high" : "low ");
+		}
 
+		/* parse panel lcd size */
 		parse_read_prop(node, "width-mm", panel->width_mm);
 		parse_read_prop(node, "height-mm", panel->height_mm);
 
diff --git a/drivers/gpu/drm/nexell/nx_drm_tv.c b/drivers/gpu/drm/nexell/nx_drm_tv.c
index bd8b8d2..e35ee90 100644
--- a/drivers/gpu/drm/nexell/nx_drm_tv.c
+++ b/drivers/gpu/drm/nexell/nx_drm_tv.c
@@ -51,7 +51,6 @@ struct nx_v4l2_i2c_board_info {
 struct tv_context {
 	struct drm_connector *connector;
 	int crtc_pipe;
-	unsigned int possible_crtcs_mask;
 	struct reset_control *reset;
 	void *base;
 	struct nx_drm_device *display;
@@ -326,13 +325,11 @@ static int panel_tv_bind(struct device *dev,
 	struct platform_driver *pdrv = to_platform_driver(dev->driver);
 	enum dp_panel_type panel_type = dp_panel_get_type(ctx->display);
 	int pipe = ctx->crtc_pipe;
-	unsigned int possible_crtcs = ctx->possible_crtcs_mask;
 	int err = 0;
 
 	DRM_INFO("Bind %s panel\n", dp_panel_type_name(panel_type));
 	ctx->connector = nx_drm_connector_create_and_attach(drm,
-			ctx->display, pipe, possible_crtcs,
-			panel_type, ctx);
+			ctx->display, pipe, panel_type, ctx);
 
 	if (IS_ERR(ctx->connector))
 		goto err_bind;
@@ -509,11 +506,6 @@ static int panel_tv_parse_dt(struct platform_device *pdev,
 	parse_read_prop(node, "crtc-pipe", ctx->crtc_pipe);
 
 	/*
-	 * get possible crtcs
-	 */
-	parse_read_prop(node, "crtcs-possible-mask", ctx->possible_crtcs_mask);
-
-	/*
 	 * parse panel output for RGB/LVDS/MiPi-DSI
 	 */
 	err = nx_drm_dp_panel_dev_register(dev, node, panel_type, display);
@@ -597,6 +589,12 @@ static int panel_tv_driver_setup(struct platform_device *pdev,
 
 	DRM_INFO("Load %s panel\n", dp_panel_type_name(type));
 
+#if 0
+	err = nx_drm_dp_panel_drv_res_parse(dev, &ctx->base, &ctx->reset);
+	if (0 > err)
+		return -EINVAL;
+#endif
+
 	err = nx_drm_dp_panel_res_parse(dev, res, type);
 	if (0 > err)
 		return -EINVAL;
@@ -806,6 +804,10 @@ static int panel_tv_remove(struct platform_device *pdev)
 
 	if (!ctx)
 		return 0;
+#if 0
+	nx_drm_dp_panel_dev_res_free(dev, &ctx->display->res);
+	nx_drm_dp_panel_drv_res_free(dev, ctx->base, ctx->reset);
+#endif
 
 	nx_drm_dp_panel_res_free(dev, &ctx->display->res);
 	nx_drm_dp_panel_dev_release(dev, ctx->display);
-- 
2.7.4

